package secp256k1

import (
	"encoding/base64"
	"testing"

	"github.com/stretchr/testify/assert"
)

// Creates and checks a KeccakSecp256k1 instruction against the following rust code:
//
//  let sk_bytes = base64::decode("bNyQVhCtQ86p9CCtzVkrg3Fm6WJqiYb+dMO4HDtbl6o=").unwrap();
//  let sk = libsecp256k1::SecretKey::parse_slice(&sk_bytes).unwrap();
//  let instr = solana_sdk::secp256k1_instruction::new_secp256k1_instruction(&sk, "message".as_bytes());
//  println!("{}", base64::encode(instr.data))
//
// As all that's in a KeccakSecp256k1 instruction is the program id and the data (no accounts are passed),
// we just check that the instruction data matches that generated by the rust code

func TestNewSecp256k1Instruction(t *testing.T) {
	//skBytes, err := base64.StdEncoding.DecodeString("bNyQVhCtQ86p9CCtzVkrg3Fm6WJqiYb+dMO4HDtbl6o=")
	//assert.NoError(t, err)
	//sk := crypto.ToECDSAUnsafe(skBytes)

	//pubkey := crypto.PubkeyToAddress(sk.PublicKey).Bytes()
	//t.Log(base64.StdEncoding.EncodeToString(pubkey))

	pubkey, _ := base64.StdEncoding.DecodeString("rx8O5L8N25rze03Dr4YXi9E+/Ys=")

	//hash := crypto.Keccak256([]byte("message"))
	//sig, err := crypto.Sign(hash, sk)
	//t.Log(base64.StdEncoding.EncodeToString(sig))

	sig, _ := base64.StdEncoding.DecodeString("K2mYts9f1v1hJc2kp2nCTZ6hZ9dhoHfADHW9zUCBftFTeN1lYUZEgoUZrklfifnZeWUJUujShZKgYtzoKMaRCgE=")

	instr, err := NewSecp256k1Instruction([][]byte{[]byte("message")}, [][]byte{sig}, [][]byte{pubkey}, 0)
	assert.NoError(t, err)

	checkDataStr := "ASAAAAwAAGEABwAArx8O5L8N25rze03Dr4YXi9E+/YsraZi2z1/W/WElzaSnacJNnqFn12Ggd8AMdb3NQIF+0VN43WVhRkSChRmuSV+J+dl5ZQlS6NKFkqBi3OgoxpEKAW1lc3NhZ2U="
	instrDataStr := base64.StdEncoding.EncodeToString(instr.Data)
	assert.Equal(t, checkDataStr, instrDataStr)
}
